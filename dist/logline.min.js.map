{"version":3,"file":"logline.min.js","sources":["../src/lib/util.ts","../src/protocols/interface.ts","../src/lib/pool.ts","../src/protocols/indexeddb.ts","../src/protocols/localstorage.ts","../src/protocols/websql.ts","../src/logline.ts"],"sourcesContent":["// throw out Errors, with global prefix 'Logline: ' ahead of err.message\nexport function throwError(errMessage) {\n    throw new Error('Logline: ' + errMessage);\n}\n\n// filter any function in a object\nexport function filterFunction(obj) {\n    var newObj = {}, i;\n\n    if (typeof obj !== 'object') {\n        return obj;\n    }\n\n    for (i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            if (typeof obj[i] !== 'function') {\n                newObj[i] = filterFunction(obj[i]);\n            }\n        }\n    }\n    return newObj;\n}\n","import * as util from '../lib/util';\n\n/**\n * Logline Interface\n * @class Interface\n */\nexport default class Logger {\n    protected _namespace:string;\n    /**\n     * Logline constructor\n     * @constructor\n     * @param {String} namespace - namespace to use\n     */\n    constructor(namespace?) {\n        this._namespace = namespace;\n    }\n\n    /**\n     * add a log record\n     * @method _reocrd\n     * @private\n     * @parma {String} level - log level\n     * @param {String} descriptor - to speed up search and improve understanding\n     * @param {Mixed} [data] - additional data\n     */\n    _record(level, descriptor?, data?) {\n        util.throwError('method _record is not implemented.');\n    }\n\n    /**\n     * add a level-info record\n     * @method info\n     * @param {String} descriptor - to speed up search and improve understanding\n     * @param {Mixed} [data] - additional data\n     */\n    info(...args) {\n        this._record('info', ...args);\n    }\n\n    /**\n     * add a level-warn record\n     * @method warn\n     * @param {String} descriptor - to speed up search and improve understanding\n     * @param {Mixed} [data] - additional data\n     */\n    warn(...args) {\n        this._record('warn', ...args);\n    }\n\n    /**\n     * add a level-error record\n     * @method error\n     * @param {String} descriptor - to speed up search and improve understanding\n     * @param {Mixed} [data] - additional data\n     */\n    error(...args) {\n        this._record('error', ...args);\n    }\n\n    /**\n     * add a level-critical record\n     * @method critical\n     * @param {String} descriptor - to speed up search and improve understanding\n     * @param {Mixed} [data] - additional data\n     */\n    critical(...args) {\n        this._record('critical', ...args);\n    }\n\n    /**\n     * initialize protocol\n     * @method init\n     * @static\n     * @param {String} database - database name to use\n     */\n    static init(database?) {\n    }\n\n    /**\n     * transform human readable time string, such as '3d', '.3' and '1.2' into Unix timestamp\n     * the default relative time is Date.now(), if no second parameter is provided\n     * @method transTimeFormat\n     * @static\n     * @param {String} time - time string to transform\n     * @param {Number} [relative] - relative time to compare, default Date.now()\n     * @return {Number|NaN} timestamp transformed\n     */\n    static transTimeFormat(time, relative?) {\n        // if falsy value or timestamp already, pass it through directly,\n        if (!time || /^\\d{13}$/.test(time)) {\n            return +time;\n        }\n        // incase relative time isn't unix timestamp format,\n        // neither a falsy value which will turned out to be Date.now()\n        if (relative && !/^\\d{13}$/.test(relative)) {\n            throw new TypeError('relative time should be standard unix timestamp');\n        }\n\n        return (relative || Date.now()) - time.replace(/d$/, '') * 24 * 3600 * 1000;\n    }\n\n    /**\n     * get logs in range\n     * if from and end is not defined, will fetch full log\n     * @method get\n     * @static\n     * @param {String} from - time from, unix timestamp\n     * @param {String} to - time end, unix timestamp\n     * @param {Function} readyFn - function to call back with logs as parameter\n     */\n    static get(from, to, readyFn) {\n        util.throwError('method get is not implemented.');\n    }\n\n    /**\n     * clean logs = keep limited logs\n     * @method keep\n     * @static\n     * @param {Number} daysToMaintain - keep logs within days\n     */\n    static keep(daysToMaintain) {\n        util.throwError('method keep is not implemented.');\n    }\n\n    /**\n     * delete log database\n     * @method clean\n     * @static\n     */\n    static clean() {\n        util.throwError('method clean is not implemented.');\n    }\n\n    /**\n     * protocol status map\n     * @prop {Object} STATUS\n     */\n    public static get STATUS() {\n        return {\n            INITING: 1,\n            INITED: 2,\n            FAILED: 4\n        };\n    }\n}\n","/**\n * Pool, for storage of async calling\n * @class Pool\n */\nexport default class Pool {\n    private _pool:object[];\n    /**\n     * Pool constructor\n     * @constructor\n     */\n    constructor() {\n        this._pool = [];\n    }\n\n    /**\n     * add an procedure\n     * @method push\n     * @param {Function} handler - procedure handler\n     * @param {Object} context - procedure context\n     */\n    push(handler, context) {\n        handler.context = context;\n        this._pool.push(handler);\n    }\n\n    /**\n     * consume pool\n     * @method consume\n     */\n    consume() {\n        var handler;\n        while ((handler = this._pool.shift())) {\n            handler.call(handler.context);\n        }\n    }\n}\n","import LoggerInterface from './interface';\nimport Pool from '../lib/pool';\nimport * as util from '../lib/util';\n\n/**\n * IndexedDB protocol\n * @class IndexedDBLogger\n */\nexport default class IndexedDBLogger extends LoggerInterface {\n    /**\n     * IndexedDB protocol constructor\n     * @constructor\n     * @param {String} namespace - namespace to use\n     */\n    constructor(...args) {\n        super(...args);\n    }\n\n    static status:number;\n    static _pool:any;\n    static db:any;\n    static _database:any;\n    static request:any;\n\n    /**\n     * add a log record\n     * @method _reocrd\n     * @private\n     * @parma {String} level - log level\n     * @param {String} descriptor - to speed up search and improve understanding\n     * @param {Mixed} [data] - additional data\n     */\n    _record(level, descriptor, data) {\n        if (IndexedDBLogger.status !== LoggerInterface['STATUS'].INITED) {\n            IndexedDBLogger._pool.push(() => this._record(level, descriptor, data));\n            if (IndexedDBLogger.status !== LoggerInterface['STATUS'].INITING) {\n                IndexedDBLogger.init();\n            }\n            return;\n        }\n\n        let transaction = IndexedDBLogger.db.transaction(['logs'], IDBTransaction.READ_WRITE || 'readwrite');\n        transaction.onerror = event => util.throwError(event.target.error);\n\n        let store = transaction.objectStore('logs');\n        // should not contains any function in data\n        // otherwise 'DOMException: Failed to execute 'add' on 'IDBObjectStore': An object could not be cloned.' will be thrown\n        let request = store.add({\n            time: Date.now(),\n            level: level,\n            namespace: this._namespace,\n            descriptor: descriptor,\n            data: util.filterFunction(data)\n        });\n\n        request.onerror = event => {\n            IndexedDBLogger.status = LoggerInterface['STATUS'].FAILED;\n            util.throwError(event.target.error);\n        };\n    }\n\n    /**\n     * initialize protocol\n     * @method init\n     * @static\n     * @param {String} database - database name to use\n     */\n    static init(database?) {\n        if (!IndexedDBLogger.support) {\n            util.throwError('your platform does not support indexeddb protocol.');\n        }\n\n        if (IndexedDBLogger.status) {\n            return false;\n        }\n\n        IndexedDBLogger._pool = IndexedDBLogger._pool || new Pool();\n        IndexedDBLogger._database = database || 'logline';\n        IndexedDBLogger.status = super['STATUS'].INITING;\n\n        IndexedDBLogger.request = window.indexedDB.open(IndexedDBLogger._database);\n        IndexedDBLogger.request.onerror = event => util.throwError('protocol indexeddb is prevented.');\n        IndexedDBLogger.request.onsuccess = event => {\n            IndexedDBLogger.db = event.target.result;\n            IndexedDBLogger.status = super['STATUS'].INITED;\n            IndexedDBLogger._pool.consume();\n            // globally handle db request errors\n            IndexedDBLogger.db.onerror = event => util.throwError(event.target.error);\n        };\n        IndexedDBLogger.request.onupgradeneeded = event => {\n            // init dabasebase\n            let db = event.target.result, store = db.createObjectStore('logs', { autoIncrement: true });\n            store.createIndex('namespace', 'namespace', { unique: false });\n            store.createIndex('level', 'level', { unique: false });\n            store.createIndex('descriptor', 'descriptor', { unique: false });\n            store.createIndex('data', 'data', { unique: false });\n        };\n    }\n\n    /**\n     * get logs in range\n     * if from and end is not defined, will fetch full log\n     * @method get\n     * @static\n     * @param {String} [from] - time from, unix time stamp or falsy\n     * @param {String} [to] - time end, unix time stamp or falsy\n     * @param {Function} readyFn - function to call back with logs as parameter\n     */\n    static get(from?, to?, readyFn?) {\n        if (IndexedDBLogger.status !== super['STATUS'].INITED) {\n            return IndexedDBLogger._pool.push(() => IndexedDBLogger.get(from, to, readyFn));\n        }\n\n        from = LoggerInterface.transTimeFormat(from);\n        to = LoggerInterface.transTimeFormat(to);\n\n        let store = IndexedDBLogger._getTransactionStore(IDBTransaction.READ_ONLY);\n\n        // IDBObjectStore.getAll is a non-standard API\n        if (store.getAll) {\n            let result, logs = [];\n            store.getAll().onsuccess = event => {\n                result = event.target.result;\n                for (let i = 0; i < result.length; i++) {\n                    if ((from && result[i].time < from) || (to && result[i].time > to)) {\n                        continue;\n                    }\n                    logs.push(result[i]);\n                }\n                readyFn(logs);\n            };\n        } else {\n            let request = store.openCursor(), logs = [];\n            request.onsuccess = event => {\n                var cursor = event.target.result;\n                if (cursor) {\n                    if ((from && cursor.value.time < from) || (to && cursor.value.time > to)) {\n                        return cursor.continue();\n                    }\n\n                    logs.push({\n                        time: cursor.value.time,\n                        level: cursor.value.level,\n                        namespace: cursor.value.namespace,\n                        descriptor: cursor.value.descriptor,\n                        data: cursor.value.data\n                    });\n                    cursor.continue();\n                }\n                else {\n                    readyFn(logs);\n                }\n            };\n        }\n    }\n\n    /**\n     * clean logs = keep limited logs\n     * @method keep\n     * @static\n     * @param {Number} daysToMaintain - keep logs within days\n     */\n    static keep(daysToMaintain) {\n        if (IndexedDBLogger.status !== super['STATUS'].INITED) {\n            return IndexedDBLogger._pool.push(() => IndexedDBLogger.keep(daysToMaintain));\n        }\n\n        let store = IndexedDBLogger._getTransactionStore(IDBTransaction.READ_WRITE);\n        if (!daysToMaintain) {\n            let request = store.clear().onerror = event => util.throwError(event.target.error);\n        }\n        else {\n            let range = (Date.now() - (daysToMaintain || 2) * 24 * 3600 * 1000);\n            let request = store.openCursor();\n            request.onsuccess = event => {\n                let cursor = event.target.result;\n                if (cursor && cursor.value.time < range) {\n                    store.delete(cursor.primaryKey);\n                    cursor.continue();\n                }\n            };\n            request.onerror = event => util.throwError('unable to locate logs earlier than ' + daysToMaintain + 'd.');\n        }\n    }\n\n    /**\n     * delete log database\n     * @method clean\n     * @static\n     */\n    static clean() {\n        if (IndexedDBLogger.status !== super['STATUS'].INITED) {\n            return IndexedDBLogger._pool.push(() => IndexedDBLogger.clean());\n        }\n\n        // database can be removed only after all connections are closed\n        IndexedDBLogger.db.close();\n        let request = window.indexedDB.deleteDatabase(IndexedDBLogger._database);\n        request.onerror = (event:any) => util.throwError(event.target.error);\n        /* eslint no-unused-vars: \"off\" */\n        request.onsuccess = event => {\n            delete IndexedDBLogger.status;\n            delete IndexedDBLogger.db;\n        };\n    }\n\n    /**\n     * get internal transaction store\n     * @method _getTransactionStore\n     * @private\n     * @static\n     * @param {String} mode - transaction mode\n     * @return {Object} - internal object store\n     */\n    static _getTransactionStore(mode) {\n        if (IndexedDBLogger.db) {\n            let transaction = IndexedDBLogger.db.transaction(['logs'], mode || IDBTransaction.READ_WRITE);\n            transaction.onerror = event => util.throwError(event.target.error);\n            return transaction.objectStore('logs');\n        }\n        else {\n            util.throwError('log database is not created or connections are closed, considering init it.');\n        }\n    }\n\n    /**\n     * detect support situation\n     * @prop {Boolean} support\n     */\n    static get support() {\n        const support = !!('indexedDB' in window && 'IDBTransaction' in window && 'IDBKeyRange' in window);\n        if (support) {\n            //@ts-ignore\n            IDBTransaction.READ_WRITE = IDBTransaction.READ_WRITE || 'readwrite';\n            //@ts-ignore\n            IDBTransaction.READ_ONLY = 'readonly';\n        }\n        return support;\n    }\n}\n\ndeclare var IDBTransaction: {\n    prototype: IDBTransaction;\n    new(): IDBTransaction;\n    readonly READ_ONLY: string;\n    readonly READ_WRITE: string;\n    readonly VERSION_CHANGE: string;\n};\n","import LoggerInterface from './interface';\nimport * as util from '../lib/util';\n\n/**\n * Localstorage protocol\n * @class LocalStorageLogger\n */\nexport default class LocalStorageLogger extends LoggerInterface {\n    /**\n     * Localstorage protocol constructor\n     * @constructor\n     * @param {String} namespace - namespace to use\n     */\n    constructor(...args) {\n        super(...args);\n    }\n\n    static _database:any;\n    static status:number;\n\n    /**\n     * add a log record\n     * @method _reocrd\n     * @private\n     * @parma {String} level - log level\n     * @param {String} descriptor - to speed up search and improve understanding\n     * @param {Mixed} [data] - additional data\n     */\n    _record(level, descriptor, data) {\n        var logs = window.localStorage.getItem(LocalStorageLogger._database) ? JSON.parse(window.localStorage.getItem(LocalStorageLogger._database)) : [];\n        logs.push([\n            Date.now(),\n            this._namespace,\n            level,\n            descriptor,\n            data\n        ]);\n        try {\n            window.localStorage.setItem(LocalStorageLogger._database, JSON.stringify(logs));\n        } catch (e) { util.throwError('error inserting record'); }\n    }\n\n    /**\n     * initialize protocol\n     * @method init\n     * @static\n     * @param {String} database - database name to use\n     */\n    static init(database?) {\n        if (!LocalStorageLogger.support) {\n            util.throwError('your platform does not support localstorage protocol.');\n        }\n        LocalStorageLogger._database = database || 'logline';\n        if (!window.localStorage.getItem(LocalStorageLogger._database)) {\n            window.localStorage.setItem(LocalStorageLogger._database, JSON.stringify([]));\n        }\n        LocalStorageLogger.status = super['STATUS'].INITED;\n    }\n\n    /**\n     * get logs in range\n     * if from and end is not defined, will fetch full log\n     * @method get\n     * @static\n     * @param {String} from - time from, unix time stamp or falsy\n     * @param {String} to - time end, unix time stamp or falsy\n     * @param {Function} readyFn - function to call back with logs as parameter\n     */\n    static get(from, to, readyFn) {\n        var logs = JSON.parse(window.localStorage.getItem(LocalStorageLogger._database)), i;\n\n        from = LoggerInterface.transTimeFormat(from);\n        to = LoggerInterface.transTimeFormat(to);\n\n        for (i = 0; i < logs.length; i++) {\n            if ((from && logs[i][0] < from) || (to && logs[i][0] > to)) {\n                continue;\n            }\n\n            logs[i] = {\n                time: logs[i][0],\n                namespace: logs[i][1],\n                level: logs[i][2],\n                descriptor: logs[i][3],\n                data: logs[i][4]\n            };\n        }\n        readyFn(logs);\n    }\n\n    /**\n     * clean logs = keep limited logs\n     * @method keep\n     * @static\n     * @param {Number} daysToMaintain - keep logs within days\n     */\n    static keep(daysToMaintain) {\n        var logs = !daysToMaintain ? [] : (window.localStorage.getItem(LocalStorageLogger._database) ? JSON.parse(window.localStorage.getItem(LocalStorageLogger._database)) : []).filter(log => {\n            return log.time >= (Date.now() - (daysToMaintain || 2) * 24 * 3600 * 1000);\n        });\n        window.localStorage.setItem(LocalStorageLogger._database, JSON.stringify(logs));\n    }\n\n    /**\n     * delete log database\n     * @method clean\n     * @static\n     */\n    static clean() {\n        delete LocalStorageLogger.status;\n        window.localStorage.removeItem(LocalStorageLogger._database);\n    }\n\n    /**\n     * detect support situation\n     * @prop {Boolean} support\n     */\n    static get support() {\n        return 'localStorage' in window;\n    }\n}\n","import LoggerInterface from './interface';\nimport Pool from '../lib/pool';\nimport * as util from '../lib/util';\n\n/**\n * Websql protocol\n * @class WebsqlLogger\n */\nexport default class WebsqlLogger extends LoggerInterface {\n    /**\n     * Websql logline constructor\n     * @constructor\n     * @param {String} namespace - namespace to use\n     */\n    constructor(...args) {\n        super(...args);\n    }\n\n    static status:number;\n    static _db:any;\n    static _database:string;\n    static _pool:any;\n\n    /**\n     * add a log record\n     * @method _reocrd\n     * @private\n     * @parma {String} level - log level\n     * @param {String} descriptor - to speed up search and improve understanding\n     * @param {Mixed} [data] - additional data\n     */\n    _record(level, descriptor, data) {\n        if (WebsqlLogger.status !== LoggerInterface['STATUS'].INITED) {\n            WebsqlLogger._pool.push(() => this._record(level, descriptor, data));\n            if (WebsqlLogger.status !== LoggerInterface['STATUS'].INITING) {\n                WebsqlLogger.init();\n            }\n            return;\n        }\n\n        try {\n            WebsqlLogger._db.transaction(tx => {\n                tx.executeSql(\n                    'INSERT INTO logs (time, namespace, level, descriptor, data) VALUES(?, ?, ?, ? ,?)',\n                    [Date.now(), this._namespace, level, descriptor, (data === undefined || data === '') ? '' : (JSON.stringify(data) || '')],\n                    () => {/* empty func */},\n                    (tx, e) => { throw e.message; }\n                );\n            });\n        } catch (e) { util.throwError('error inserting record'); }\n    }\n\n    /**\n     * initialize protocol\n     * @method init\n     * @static\n     * @param {String} database - database name to use\n     */\n    static init(database?) {\n        if (!WebsqlLogger.support) {\n            util.throwError(new Error('your platform does not support websql protocol.'));\n        }\n\n        if (WebsqlLogger.status) {\n            return false;\n        }\n\n        WebsqlLogger._pool = WebsqlLogger._pool || new Pool();\n        WebsqlLogger._database = database || 'logline';\n        WebsqlLogger.status = super['STATUS'].INITING;\n\n        try {\n            WebsqlLogger._db = window.openDatabase(WebsqlLogger._database, '1.0', 'cats loves logs', 4.85 * 1024 * 1024);\n            WebsqlLogger._db.transaction(tx => {\n                tx.executeSql(\n                    'CREATE TABLE IF NOT EXISTS logs (time, namespace, level, descriptor, data)', [],\n                    () => {\n                        WebsqlLogger.status = super['STATUS'].INITED;\n                        WebsqlLogger._pool.consume();\n                    },\n                    () => {\n                        WebsqlLogger.status = super['STATUS'].FAILED;\n                    }\n                );\n            });\n        } catch (e) { util.throwError('unable to init log database.'); }\n    }\n\n    /**\n     * get logs in range\n     * if from and end is not defined, will fetch full log\n     * @method get\n     * @static\n     * @param {String} from - time from, unix time stamp or falsy\n     * @param {String} to - time end, unix time stamp or falsy\n     * @param {Function} readyFn - function to call back with logs as parameter\n     */\n    static get(from, to, readyFn) {\n        if (WebsqlLogger.status !== super['STATUS'].INITED) {\n            return WebsqlLogger._pool.push(() => WebsqlLogger.get(from, to, readyFn));\n        }\n\n        from = LoggerInterface.transTimeFormat(from);\n        to = LoggerInterface.transTimeFormat(to);\n\n        try {\n            WebsqlLogger._db.transaction(function(tx) {\n                tx.executeSql(\n                    'SELECT * FROM logs ORDER BY time DESC', [],\n                    (tx, res) => {\n                        var logs = [], line, index = res.rows.length, item;\n                        while (--index >= 0) {\n                            item = res.rows.item(index);\n                            if ((from && item.time < from) || (to && item.time > to)) {\n                                continue;\n                            }\n\n                            // in some devices, properties are configureable: false, writable: false\n                            // we need deep copy\n                            line = JSON.parse(JSON.stringify(item));\n                            // incase data is an object, not a string\n                            try { line.data = JSON.parse(line.data); }\n                            catch (e) {/* leave line.data as it be */}\n                            logs.push(line);\n                        }\n                        readyFn(logs);\n                    },\n                    (tx, e) => { throw e.message; }\n                );\n            });\n        } catch (e) { util.throwError('unable to collect logs from database.'); }\n    }\n\n    /**\n     * clean logs = keep limited logs\n     * @method keep\n     * @static\n     * @param {Number} daysToMaintain - keep logs within days\n     */\n    static keep(daysToMaintain) {\n        if (WebsqlLogger.status !== super['STATUS'].INITED) {\n            return WebsqlLogger._pool.push(() => WebsqlLogger.keep(daysToMaintain));\n        }\n\n        try {\n            WebsqlLogger._db.transaction(function(tx) {\n                if (daysToMaintain) {\n                    tx.executeSql(\n                        'DELETE FROM logs WHERE time < ?',\n                        [Date.now() - (daysToMaintain || 2) * 24 * 3600 * 1000],\n                        function() {/* empty func */},\n                        function(tx, e) {throw e.message;}\n                    );\n                }\n                else {\n                    tx.executeSql(\n                        'DELETE FROM logs', [],\n                        () => {/* empty func */},\n                        (tx, e) => { throw e.message; }\n                    );\n                }\n            });\n        } catch (e) { util.throwError('unable to clean logs from database.'); }\n    }\n\n    /**\n     * delete log database\n     * @method clean\n     * @static\n     */\n    static clean() {\n        if (WebsqlLogger.status !== super['STATUS'].INITED) {\n            WebsqlLogger._pool.push(() => WebsqlLogger.clean());\n            return;\n        }\n\n        try {\n            WebsqlLogger._db.transaction(tx => {\n                tx.executeSql(\n                    'DROP TABLE logs', [],\n                    () => {\n                        delete WebsqlLogger.status;\n                    },\n                    (tx, e) => { throw e.message; }\n                );\n            });\n        } catch (e) { util.throwError('unable to clean log database.'); }\n    }\n\n    /**\n     * detect support situation\n     * @prop {Boolean} support\n     */\n    static get support() {\n        return 'openDatabase' in window;\n    }\n}\n","import Interface from './protocols/interface';\nimport IndexeddbLogger from './protocols/indexeddb';\nimport LocalstorageLogger from './protocols/localstorage';\nimport WebsqlLogger from './protocols/websql';\nimport * as util from './lib/util';\n\n\nclass Logline {\n    /**\n     * Logline constructor\n     * @constructor\n     * @param {String} namespace - namespace to use\n     * @return {Object Protocol Instance}\n     */\n    constructor(namespace) {\n        if (!(this instanceof Logline)) {\n            return new Logline(namespace);\n        }\n        Logline._checkProtocol();\n        return new Logline._protocol(namespace);\n    }\n\n    static _protocol: any;\n    static _database: any;\n    static PROTOCOL: object;\n    static INTERFACE: object;\n\n    /**\n     * choose a protocol to initialize\n     * @method _initProtocol\n     * @private\n     * @static\n     * @param {Object Protocol Class} protocol - protocol to use, must under Logline.PROTOCOL\n     * @return {Object} Logline\n     */\n    static _initProtocol(protocol) {\n        Logline._protocol = protocol;\n        Logline._protocol.init(Logline._database || 'logline');\n    }\n\n    /**\n     * check protocol\n     * if no protocol is chosen, will try to choose an available one automatically\n     * if none of the protocols is available, an error will be thrown\n     * @method _checkProtocol\n     * @private\n     * @static\n     */\n    static _checkProtocol() {\n        if (!Logline._protocol) {\n            let protocols = Object.keys(Logline.PROTOCOL), protocol;\n            while ((protocol = Logline.PROTOCOL[protocols.shift()])) {\n                if (protocol.support) {\n                    Logline._initProtocol(protocol);\n                    return;\n                }\n            }\n\n            throw new Error(protocols.join(', ').toLowerCase() + ' protocols are not supported on this platform');\n        }\n    }\n\n    /**\n     * get logs in range\n     * if from and end is not defined, will fetch full log\n     * @method get\n     * @static\n     * @param {String} [from] - time from\n     * @param {String} [to] - time end\n     * @param {Function} readyFn - function to call back with logs as parameter\n     */\n    static get(from, to?, readyFn?) {\n        Logline._checkProtocol();\n\n        switch (arguments.length) {\n            case 1:\n                readyFn = from;\n                from = undefined;\n                break;\n            case 2:\n                readyFn = to;\n                to = undefined;\n                break;\n            case 3:\n            default:\n                break;\n        }\n\n        Logline._protocol.get(from, to, readyFn);\n    }\n\n    /**\n     * read all logs\n     * @method all\n     * @static\n     * @param {Function} readyFn - function to call back with logs as parameter\n     */\n    static all(readyFn) {\n        Logline.get(readyFn);\n    }\n\n    /**\n     * clean up logs = keep limited logs\n     * @method keep\n     * @static\n     * @param {String} daysToMaintain - specialfy days to keep, support human readable format such as '3d', '.3'\n     * @return {Object} Logline\n     */\n    static keep(daysToMaintain) {\n        Logline._checkProtocol();\n        Logline._protocol.keep(daysToMaintain);\n        return this;\n    }\n\n    /**\n     * delete log database\n     * @method clean\n     * @static\n     * @return {Object} Logline\n     */\n    static clean() {\n        Logline._checkProtocol();\n        Logline._protocol.clean();\n        return this;\n    }\n\n    /**\n     * choose a protocol\n     * @method using\n     * @static\n     * @param {Object Protocol Class} protocol - wanted protocol, should be on of Logline.PROTOCOL\n     * @param {String} [database] - custome database name\n     * @return {Object} Logline\n     */\n    static using(protocol, database) {\n        // protocol unavailable is not allowed\n        if (-1 === [IndexeddbLogger, LocalstorageLogger, WebsqlLogger].indexOf(protocol)) {\n            util.throwError('specialfied protocol ' + (protocol ? (protocol + ' ') : '') + 'is not available');\n        }\n\n        // once protocol is selected, it shall not be changed during runtime\n        if (Logline._protocol) {\n            return this;\n        }\n\n        Logline.database(database || Logline._database);\n        Logline._initProtocol(protocol);\n        return this;\n    }\n\n    /**\n     * specialfy a custome database name, in case of any conflicts\n     * @methd database\n     * @static\n     * @param {String} name - target database name\n     */\n    static database(name) {\n        Logline._database = name;\n    }\n}\n\n// export protocols for modification and mounting\nLogline.PROTOCOL = {\n    INDEXEDDB: IndexeddbLogger,\n    LOCALSTORAGE: LocalstorageLogger,\n    WEBSQL: WebsqlLogger\n};\n\n// export protocol interface for user custom implements\nLogline.INTERFACE = Object.freeze(Interface);\n\nexport default Logline;\n"],"names":["errMessage","Error","obj","i","newObj","hasOwnProperty","filterFunction","namespace","_namespace","level","descriptor","data","_i","_record","this","args","database","time","relative","test","TypeError","Date","now","replace","from","to","readyFn","daysToMaintain","Logger","_pool","handler","context","push","shift","call","IndexedDBLogger","status","LoggerInterface","INITED","_this","INITING","init","transaction","db","IDBTransaction","READ_WRITE","onerror","event","util","target","error","objectStore","add","FAILED","support","Pool","_database","_super","request","window","indexedDB","open","onsuccess","result","consume","onupgradeneeded","store","createObjectStore","autoIncrement","createIndex","unique","get","transTimeFormat","_getTransactionStore","READ_ONLY","getAll","result_1","logs_1","length","openCursor","logs_2","cursor","value","continue","keep","range_1","delete","primaryKey","clear","clean","close","deleteDatabase","mode","logs","localStorage","getItem","LocalStorageLogger","JSON","parse","setItem","stringify","e","filter","log","removeItem","WebsqlLogger","_db","tx","executeSql","undefined","message","openDatabase","res","line","item","index","rows","Logline","_checkProtocol","_protocol","protocol","protocols","Object","keys","PROTOCOL","_initProtocol","join","toLowerCase","arguments","IndexeddbLogger","LocalstorageLogger","indexOf","name","INTERFACE","freeze","Interface"],"mappings":"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"}